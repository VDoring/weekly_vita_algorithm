/*
그래프는 정점(Vertex), 정점들을 연결하는 간선(Edge)로 이루어져 있다.
정점 = 어떤 자료 등을 표현하기 위해 사용하는 수단.
간선 = 정점들. 자료간의 관계를 나타내기 위함.


용어)
정점(Vertex):
자료를 표현하기 위해 사용. 노드(node)라고도 한다

간선(Edge):
정점(자료)를 연결하여 정점 사이의 관계를 표현한다.

가중치(weight):
한 정점에서 다른 정점으로 이동하는 데 필요한 거리, 비용 등을 정의한 것으로 간선에 할당된다.
가중치가 없는 그래프의 경우 가중치를 1로 생각하면 좋다.

차수(degree):
그래프와 연결된 간선의 개수.
- 입력 차수: 그래프가 방향 그래프일 경우, 해당 정점으로 들어오는 간선의 개수.
- 출력 차수: 그래프가 방향 그래프일 경우, 해당 정점에서 나가는 간선의 개수.

단순 경로(simple path):
특정 출발점에서 도착점으로 이동하는 동안 하나의 정점을 최대 한번씩만 방문한 경로이다.
즉, 한 정점은 두 번 이상 방문할 수 없음을 말한다.

사이클(cycle):
단순 경로의 출발점과 도착점이 같은 경우를 말한다.

연결 요소(connected component):
그래프의 정점은 연결되지 않은 상태일 수 있다.
연결 요소는 연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 하며, 서로 다른 연결 요소에 속한 정점끼리 연결하는 경로는 존재해선 안 된다.


종류)
양방향(무방향) 그래프(undirected graph):
간선에 방향이 없는 그래프.
간선이 연결되어 있다면 해당 간선을 통해 두 정점 u, v로 이동할 수 있다. 즉 u->v, v->u 둘은 같은 간선이다.

방향 그래프(drected graph):
간선에 방향이 있는 그래프.
u->v, v->u 둘은 다른 간선이다.

완전 그래프(complete graph):
각 정점에서 자신을 제외한 모든 정점과 연결된 그래프.
간선의 개수는 방향 그래프는 V(V - 1), 양방향 그래프는 V(V - 1)/2이다.

다중 그래프(multigraph):
두 정점 사이에 간선이 여러 개 있는 그래프.

사이클 없는 방향 그래프(directed acyclic graph):
DAG라고도 한다.

부분 그래프(subgraph):
어떤 그래프에서 정점(들)이나 간선(들)을 제외하여 만든 그래프.

이분 그래프(bipartite graph):
인접한 정점끼리 서로 다른 색으로 칠했을때, 모든 정점을 두가지 색으로만 칠할 수 있는 그래프.
약간 다르게 표현하면.. 두 개의 정점을 두 그룹으로 나누어 같은 그룹에 속한 정점끼리는 연결되어 있지 않은 그래프를 말한다.
*/


//컴퓨터에서 그래프를 표현하는 방법)
/*
인접 행렬:
그래프 내 두 정점이 연결되어 있는지를 판단하는 연산 또는 해당 정점에 연결된 모든 정점을 착는 연산을 주로 이용.
행렬의 특성상 특정 그래프 표현시 정점의 제곱인 O(V²)만큼의 공간을 필요로 해서, 정점의 개수가 많이지는 경우엔 사용하기 어렵다.
행렬의 i행 j열로 확인 할 수 있어 O(1) 시간밖에 걸리지 않고, 특정 정점에 연결된 모든 정점을 찾기 위해 모든 정점의 개수만큼 일일이 확인해야 하므로 O(V)시간 안에 확인할 수 있다.
*/
#define VMAX 1010 //정점의 최대 개수
int adj[VMAX][VMAX] = { 0 }; //인접 행렬로 사용할 배열 선언

int v, w; cin >> v; //정점의 개수를 입력으로 받음
for (int i = 0; i < v; ++i) { //인접 행렬의 모든 요소에 대해 입력을 받음
	for (int j = 0; j < v; ++j) {
		cin >> w;
		adj[i][j] = w;
	}
}

/*
인접 리스트:
연결 리스트(Linked List) 또는 동적 배열인 백터를 이용하여 정점에 연결된 모든 간선을 저장한다.
두 정점의 연결 여부를 확인하기 위해 해당 노드와 연결된 모든 요소를 확인하므로, 해당 정점의 차수인 O(d)의 시간이 걸린다.
그뿐만 아니라 해당 정점과 연결된 모든 정점을 찾는 것 역시 O(d)의 시간이 걸린다.
*/
#define VMAX 1010 //정점의 최대 개수
struct EDGE { //간선의 정보(어떤 정점으로 연결되어 있는지와 가중치)
	int v, w;
};
vector<EDGE> adj[VMAX]; //인접 리스트로 사용하기 위한 변수

int v, e, from, to, w;
cin >> v >> e; //정점과 간선의 개수를 입력으로 받음
for (int i = 0; i < e; ++i) { //간선의 개수만큼 입력 받음
	cin >> from >> to >> w; //출발 정점, 도착 정점, 가중치를 입력 받음
	adj[from].push_back({ to, w });
	adj[to].puch_back({ from, w }); //방향 그래프인 경우 이 줄은 사용하지 않음
}