/*
너비 우선 탐색(BFS)
= 그래프를 방문하거나 탐색하는 방법의 하나이다.

BFS를 이용해 최솟값(최단거리, 최소비용 등)과 관련된 문제를 해결할 수 있다.
이때 그래프의 가중치(시간, 비용, 거리)가 1이어야만 한다.

BFS 절차)
1. 저장된 정점 중 첫 번째 정점을 선택하여 저장된 정점에서 제거
2. 제거한 정점에서 해야 할 작업 진행
3. 제거한 정점과 연결된 정점 중 방문하지 않은 모든 정점 저장(2번과 3번은 순서가 바껴도 상관없음)
4. 저장된 정점에 모든 노드가 제거될 때까지 1~3번 과정을 반복
(그림 예시는 사이트 방문해서 보기)

큐(Queue)로 구현할 수 있다.
예시에서는 정점을 저장하고 저장된 정점 중 가장 먼저 저장된 정점을 선택하며 해당 정점에 대한 작업까지의 과정이 반복된다.


깊이 우선 탐색(DFS: Depth First Search)와의 차이:
DFS는 그래프의 최대 경로(최대 깊이)가 예측할 수 있나 유한한 범위여야만 사용할 수 있다.
하지만 BFS는 모든 경로에 대한 동시 탐색이 가능하여 최대 경로를 몰라도 사용할 수 있다.
이 특징으로 인해 최단거리, 최소비용 등을 구할 수 있다.
*/

void bfs(int start) {
	bool chk[1010] = { 0 };
	queue<int> q;

	q.push(start); //시작점을 큐에 저장
	chk[start] = 1; //시작점을 방문했다고 표시

	while (q.size()) {
		int cur = q.front(); //큐에 저장되어 있는 정점 중 가장 먼저 저장된 정점을 선택
		q.pop(); //선택 후 제거
		for (int i = 0; i < adj[cur].size(); ++i) {
			int next = adj[cur][i];
			if (!chk[next]) {
				!chk[next] = 1;
				q.push(next);
			}
		}
	}
}

/* [여담]
C++로 큐(Queue) 사용하기

큐 선언하기:
queue<int> q;

큐에 데이터 넣기:
q.push(1);
q.push(2);

큐에 넣은 데이터 꺼내기:
q.pop();

*/