#include <iostream>
using namespace std;

int main() {
	long long n;
	scanf("%lld", &n);

	if ((n & (-n)) == n) printf("Yes");
	else printf("No");

	return 0;
}

/*
[거듭제곱 판별하기]
https://sonsh0824.tistory.com/entry/2%EC%9D%98-%EA%B1%B0%EB%93%AD%EC%A0%9C%EA%B3%B1-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0
https://edu.goorm.io/learn/lecture/15551/%EC%9C%84%ED%81%B4%EB%A6%AC-%EB%B9%84%ED%83%80%EC%95%8C%EA%B3%A0-%EC%8B%9C%EC%A6%8C2-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EB%B9%84-%EC%9E%85%EB%AC%B8%ED%8E%B8/lesson/736434/09%EC%9B%94-1%EC%A3%BC%EC%B0%A8-%EC%88%98%EC%9D%98-%EB%B9%84%EB%B0%80-%ED%95%B4%EC%84%A4

결론:
어떤 자연수 n에 대해 (n & (-n)) == n 이면, 그 수는 2의 거듭제곱이다.


1. 2의 거듭제곱 수의 비트표현을 보면 한자리만 1이고 나머지는 모두 0이다.
ex) 32는 이진수로 100000, 8은 1000이다.

2. 주어진 수의 음수는 1의 보수를 취하고, 1을 더하여 비트 표현을 구할 수 있는데, 2의 거듭제곱 수의 보수는 한자리만 0이다.
이 수에 1을 더하게 되면 0이었던 자리를 포함해 상위비트는 모두 1이고 하위비트는 0이 된다.
ex) 32는 이진수로 100000인데, 보수를 취하면 111...011111이고, 1을 더하게 되면 111...100000가 된다.

3. 2의 거듭제곱 수가 아닌 경우엔, 하위비트로부터 상위비트를 읽어나갈때 처음으로 나오는 1까지의 비트가 0이 되고, 처음 나오는 1은 1이며, 그 상위비트는 기존 비트의 반대가 된다.
ex) 35는 이진수로 100011인데, -35는 111...011101이 된다.
	12는 1100이고, -12는 11...10100이다.

*/